#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <ostream>
#include <tuple>
#include <algorithm>
#include <cstdlib>
#include <ctime>



using namespace std;


// -----------------------------------------------------------------------------
// ----------------------- Récupération des donneés -----------------------
// -----------------------------------------------------------------------------


struct joueur {
    string nom;
    string prenom;
    unsigned numEquipe;
    unsigned points ;
};


// ------------ saisirEquipe -----------
vector<vector<joueur>> saisirEquipe (const string & chemin){
    // Recupere les joueurs de chaques equipes a partir d'un fichier passe en parametre
    ifstream ifs (chemin);
    string nom;
    string prenom;
    string numEquipeStr;
    unsigned point = 0;
    vector<vector<joueur>> equipes (19);
    //cout << "Recuperation des equipes." << endl;
    for(int i = 0; i < 114; ++i){
        getline (ifs, nom);
        //cout << nom << endl;
        getline (ifs, prenom);
        //cout << prenom << endl;
        getline(ifs, numEquipeStr);
        //cout << numEquipeStr << endl;
        unsigned numEquipe = stoi(numEquipeStr);
        equipes[numEquipe-1].push_back(joueur {nom, prenom, numEquipe, point});
    }
    return equipes;
}


// ------------ recuperationGraineEtTournoi -----------
vector<int> recuperationGraineEtTournoi (const string & chemin){
    // Recupere la graine et le tournoi a partir d'un fichier passe en parametre.
    /*
     * Rentrez 1 pour un tournoi ligue 1.
     * Rentrez 2 pour un tournoi suisse.
     * Rentrez 3 pour un tournoi sans loser bracket.
     * Rentrez 4 pour un tournoi avec loser bracket.
    */
    ifstream ifs (chemin);
    string vent;
    string graine ;
    string tournoi ;
    for(int i = 0; i < 114; ++i){
        getline (ifs, vent);
        getline (ifs, vent);
        getline(ifs, vent);
    }
    getline(ifs, tournoi);
    int tournoi_Int = stoi(tournoi);
    getline(ifs, graine);
    //cout << "la graine est : " << graine <<endl ;
    int graine_Int = stoi(graine);
    //cout << "---------------------" << endl;
    return {tournoi_Int, graine_Int};
}


// -----------------------------------------------------------------------------
// ----------------------- Jeux -----------------------
// -----------------------------------------------------------------------------


// ------------ pileOuFace -----------
unsigned pileOuFace(const unsigned & j1, const unsigned j2) {
    //Affronte deux equipes au pile ou face
    //0 pour pile et 1 pour face
    //cout << "Les equipes " <<  j1 << " et " << j2 << " s'affrontent sur le pile ou face." << endl;
    int resultat = rand() % 2;
    if (resultat == 0) {
        //cout << "Le gagant de la manche est l'equipe " << j1 << endl << endl;
        return j1;
    }
    //cout << "Le gagant de la manche est l'equipe " << j2 << endl << endl;
    return j2;
}


// ------------ shifumi -----------
unsigned shifumi(const unsigned & j1, const unsigned j2) {
    //Affronte deux equipes au shifumi
    //0 pour Pierre, 1 pour Papier, 2 pour Ciseaux
    //cout << "Les equipes " <<  j1 << " et " << j2 << " s'affrontent sur le shifumi." << endl;
    string coupj1 = to_string(rand() % 2);
    string coupj2 = "2";
    while (true){
        if ((coupj1 == "0" && coupj2 == "2") || (coupj1 == "1" && coupj2 == "0") || (coupj1 == "2" && coupj2 == "1")) {
            //cout << "Le gagant de la manche est l'equipe " << j1 << endl;
            return j1;
        }
        else {
            //cout << "Le gagant de la manche est l'equipe " << j2 << endl;
            return j2;
        }
    }
}


// ------------ justePrix -----------
unsigned justePrix(const unsigned & j1, const unsigned & j2){
    //cout << endl << "Les equipes " <<  j1 << " et " << j2 << " s'affrontent sur le juste prix." << endl;
    int nbSecret = rand() % 10;
    //cout << "Le nombre secret est " << nbSecret << endl;
    bool j1Turn = true;
    int limiteMin = 0;
    int limiteMax = 10;
    int coupJ;
    while(true){
        coupJ = (rand() % (limiteMax - limiteMin)) + limiteMin;
        if(j1Turn){
            //cout << "L'equipe 1 pense au nombre "<< coupJ << endl;
            if(coupJ == nbSecret){
                //cout << "Le gagant de la manche est l'equipe " << j1 << endl;
                return j1;
            }else if(coupJ > nbSecret){
                //cout << coupJ << " trop grand j1" << endl;
                limiteMax = coupJ ;
            }else{
                limiteMin = coupJ ;
                //cout << coupJ << " trop petit j1" << endl;
            }
            j1Turn = false;
        }else{
            //cout << "L'equipe 2 pense au nombre " << coupJ << endl;
            if(coupJ == nbSecret){
                //cout << "Le gagant de la manche est l'equipe " << j2 << endl;
                return j2;
            }else if(coupJ > nbSecret){
                // << coupJ << " trop grand j2" << endl;
                limiteMax = coupJ;
            }else{

                limiteMin = coupJ;
                //cout << coupJ << " trop petit j2" << endl;
            }
            j1Turn = true;
        }
    }
}

// ------------ JeuDuCailloux -----------
unsigned jeuDuCailloux (const unsigned & j1, const unsigned & j2){
    //Affronte deux equipes au jeu du cailloux
    //cout << endl << "Les equipes " <<  j1 << " et " << j2 << " s'affrontent sur le jeu du caillou." << endl;
    int result1 = 3;
    int result2 = 3;
    bool estTourJ1 = true;
    int coupJ1;
    int coupJ2;
    int Gagnant;
    while (true){
        // Calcul des coups des deux joueurs
        coupJ1 = (rand() % 3)+1;
        coupJ2 = (rand() % 3)+1;
        // Affichage
        if (estTourJ1){
            //cout << "L'equipe " << j1 << " cache " << coupJ1 <<" cailloux et " << "l'equipe " << j2 << " pense qu'elle en cache " << coupJ2 << endl ;
        }
        else{
            //cout << "L'equipe "<< j2 << " cache " << coupJ2 <<" cailloux et " <<  "l'equipe " <<j1 << " pense qu'elle en cache " << coupJ1 << endl ;
        }
        // Condition de victoire du tour
        if ((coupJ1 == coupJ2 && estTourJ1) ) { // 2 doit deviner, a raison, donc prend le nombre que 1 a caché
            result2 += coupJ1;
            result1 -= coupJ1;
            //cout << "L'equipe "<< j2 << " gagne la manche." << endl ;
            //cout << "L'equipe "<< j1 << " possede " << result1 << " et " <<  "l'equipe "<< j2 << " possede " << result2 << endl ;
            estTourJ1 = false;
        }
        else if(coupJ1 != coupJ2 && estTourJ1 == 0) {// 1 doit deviner, a tord, donc 2 prend le nombre que 2 a caché
            result2 += coupJ2;
            result1 -= coupJ2;
            //cout << "L'equipe "<< j2 << " gagne la manche." << endl ;
            //cout << "L'equipe "<< j1 << " possede " << result1 << " et " <<  "l'equipe "<< j2 << " possede " << result2 << endl ;
            estTourJ1 = true;
        }
        else if ((coupJ1 == coupJ2 && estTourJ1==0) ) {// 1 doit deviner, a raison, donc prend le nombre que 2 a caché
            result2 -= coupJ2;
            result1 += coupJ2;
            //cout << "L'equipe "<< j1 << " gagne la manche." << endl ;
            //cout << "L'equipe "<< j1 << " possede " << result1 << " et " <<  "l'equipe "<< j2 << " possede " << result2 << endl ;
            estTourJ1 = true;
        }
        else {// 2 doit deviner, a tord,  1 donc prend le nombre que 1 a caché
            result2 -= coupJ1 ;
            result1 += coupJ1 ;
            //cout << "L'equipe "<< j1 << " gagne la manche." << endl ;
            //cout << "L'equipe "<< j1 << " possede " << result1 << " et " <<  "l'equipe "<< j2 << " possede " << result2 << endl ;
            estTourJ1 = false;
        }
        // Condition de fin de jeu
        if (result1 < 1){
            Gagnant = j2;
            //cout << "Le gagant de la manche est l'equipe " << j2 << endl;
            break;
        }else if(result2 < 1){
            //cout << "Le gagant de la manche est l'equipe " << j1 << endl;
            Gagnant = j1;
            break;
        }

    }
    return Gagnant;
}


// ------------ Morpion ! -----------

//Affiche la grille (seulement pour debug)
void montreGrille(const vector<vector<string>> & grille){
    // Double boucle qui affiche chaque case
    for(int ligne = 0; ligne < 3; ligne += 1){
        for(int colonne = 0; colonne < 3; colonne += 1){
            cout << grille[ligne][colonne];
            if(colonne < 2){
                cout << "|";
            }
        }
        cout << endl;
        if(ligne < 2){
            cout << "------" << endl;
        }
    }
    for(int i = 0; i < 4; i += 1){
        cout << endl;
    }
}

// Regarde si le coup demander est jouable
bool estJouable(const int & ligne, const int & colonne, vector<vector<string>> grille){
    // Si l'emplacement est vide, alors le coup est jouable.
    if(grille[ligne][colonne] == " "){
        return true;
    }
    // Sinon non.
    return false;
}

// Condition de victoire
bool estGagnant(const string & forme, vector<vector<string>> grille){
    // Condition de victoire en ligne
    for(int ligne = 0; ligne < 3; ligne += 1){
        if(grille[ligne][0] == forme && grille[ligne][1] == forme && grille[ligne][2] == forme){
            return true;
        }
    }
    // Condition de victoire en Colonne
    for(int colonne = 0; colonne < 3; colonne += 1){
        if(grille[0][colonne] == forme && grille[1][colonne] == forme && grille[2][colonne] == forme){
            return true;
        }
    }
    // Condition de victoire en Diagonal de droite à gauche
    if(grille[0][0] == forme && grille[1][1] == forme && grille[2][2] == forme){
        return true;
    }
    // Condition de victoire en Diagonal de gauche à droite
    if(grille[0][2] == forme && grille[1][1] == forme && grille[2][0] == forme){
        return true;
    }

    return false;
}

// Selectionne un emplacement à partir d'un nombre
//qui renvoie les coordonnées de la case.
vector<int> selectionne_emplacement(int x){
    // Initialisation des variables
    vector<int> result{0,0};
    // Variable permettant de stop la double boucle lorsque le nombre demander est obtenu.
    int tour = 0;
    // Double boucle qui cherche l'emplacement avec "i" pour la ligne et "j" pour la colonne.
    for(int i = 0; i < 3; i += 1){
        for(int j = 0; j < 3; j += 1){
            if(tour == x){
                result[0] = i;
                result[1] = j;
                return result;
            }
            // Incrémentation du compteur. (Important)
            tour += 1;
        }
    }
    return result;
}

//Fonction principal du morpion
unsigned morpion (const unsigned & j1, const unsigned & j2){
    // Initialisation de la grille de jeu
    vector<vector<string>> grille{{" ", " ", " "},{" ", " ", " "},{" ", " ", " "}};
    // Initialisation des autres variables.
    // compteur de coup jouez
    int tour = 0;
    // Case séléctionné par le joueur
    int selection = 0;
    // Numéro de ligne de la dernière case séléctionné.
    int ligne = 0;
    // Numéro de colonne de la dernière case séléctionné.
    int colonne = 0;
    // Savoir s'il s'agit du tour du joueur 1 ou non.
    bool estTourJ1 = true;
    // La formee actuellement en train de joueur (soit 'X' soit 'O')
    string forme;
    while(true){
        // S'il s'agit du joueur 1 alors lui affecter le signe 'X' sinon 'O'
        if(estTourJ1){
            forme = "X";
        }else{
            forme = "O";
        }
        // Sélection d'une case random
        selection = rand() % 8;
        // Coordonner de la case stocker dans les variables "ligne" et "colonne"
        ligne = selectionne_emplacement(selection)[0];
        colonne = selectionne_emplacement(selection)[1];
        // Vérification pour savoir si la case est déjà occupé.
        if(estJouable(ligne, colonne, grille)){
            // La coup est jouable, alors, on passe au joueur suivant et on place la formee actuelle
            if(estTourJ1){
                estTourJ1 = false;
            }else{
                estTourJ1 = true;
            }
            tour += 1;
            grille[ligne][colonne] = forme;
            //cout << forme << " place à " << selection << endl;
        }
        // debug
        //montreGrille(grille);
        // Verification des conditions de victoire.
        if(estGagnant(forme, grille)){
            // Condition vrai, alors, Vérification de la formee actuelle
            if(forme == "X"){
                // Si la formee est 'X' alors le joueur 1 gagne.
                //cout << "Le gagant de la manche est l'equipe " << j1 << endl;
                return j1;
            }else{
                // Si la formee est 'O' alors le joueur 2 gagne.
                //cout << "Le gagant de la manche est l'equipe " << j2 << endl;
                return j2;
            }
        }
        // Si le nombre de coup joué est égal à 9, alors il n'y a plus de place sur le plateau.
        if(tour == 9){
            // un match nul est déclarer, par défaut le joueur 1 gagne.
            //cout << "Match nul" << endl;
            return j1;
        }
    }
}

// -----------------------------------------------------------------------------
// ----------------------- Tournoi -----------------------
// -----------------------------------------------------------------------------

/*
void affichTabJoueur (const vector<vector<joueur>> & vJ){
    //    for (const auto & equipe  : vector<vector<joueur>>){
    for (size_t i (0); i < vJ.size(); ++i) {
        //cout << "numero equipe : " << i+1 << endl;
        for (const auto & _joueur  : vJ[i])
            //cout << _joueur.nom << " " << _joueur.prenom << endl;
    }
}
*/

size_t equipeGagnante(const vector<vector<joueur>> & vJoueur, const size_t & posEquipe1, const size_t & posEquipe2) {
    return posEquipe1; //(vJoueur[posEquipe1][0].points > vJoueur[posEquipe2][0].points) ? posEquipe1 : posEquipe2;
}



// ------------ tournoiSansLoserBracket -----------
size_t tournoiSansLoserBracket (vector<vector<joueur>> & vJoueur){
    //Affronte 16 équipes dans un format de tournoi sans loser bracket
    //Redimensionne le tableau de joueurs pour avoir seulement 16 équipes qu'y s'affrontent
    if (vJoueur.size() > 16) vJoueur.resize(16);
    cout << endl << "Les equipes vont s'affronter dans un tournoi sans loser bracket."  ;

    while (vJoueur.size() > 1){ //La boucle s'arrete quand il ne reste qu'un joueur dans VJoueur
        //cout << endl << endl << "Debut du round "  << endl;
        //cout << "Il y a " << vJoueur.size() << " participants" << endl;
        //Création d'un vector de vector de joueur qui va stocker les gagnants pour le prochain tour.
        vector<vector<joueur>> prochainRoundVJouer;
        //Cette boucle permet de confronter les equipes 2 a 2.
        for (size_t i (0); i < vJoueur.size(); i += 2) {
            //cout << endl <<"Les equipes " <<  vJoueur[i][0].numEquipe << " et " << vJoueur[i+1][0].numEquipe << " s'affrontent." << endl;

            // Le gagnant de chaque jeu est stocké dans la variable gagnant.
            unsigned gagnant = pileOuFace(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            // On recupere l'indice du gagnant,
            // Si gagant vaut vJoueur[i][0].numEquipe alors equipeGagnanteIndex sera egal a i.
            // Sinon equipeGagnanteIndex vaut i+1
            size_t equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            // Les points du gagant augmentent de 1
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = shifumi(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = justePrix(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = jeuDuCailloux(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;


            gagnant = morpion(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            //On rajoute a la fin du vector prochainRoundVJouer le gagnant afin qu'il puisse jouer le prochain round.
            equipeGagnanteIndex = (vJoueur[i][0].points > vJoueur[i+1][0].points) ? i : i + 1;
            prochainRoundVJouer.push_back(vJoueur[equipeGagnanteIndex]);
            // On remet les scores a 0.
            vJoueur[i][0].points = 0;
            vJoueur[i+1][0].points = 0;
        }
        vJoueur = prochainRoundVJouer;
    }
    cout << endl << "c'est l'equipe " << vJoueur[0][0].numEquipe << " qui a gagne." << endl;
    return size_t(vJoueur[0][0].numEquipe);
}


// ------------ tournoiAvecLoserBracket -----------
size_t tournoiAvecLoserBracket(vector<vector<joueur>> & vJoueur) {
    //Affronte 16 équipes dans un format de tournoi avec loser bracket
    //Redimensionne le tableau de joueurs pour avoir seulement 16 équipes qu'y s'affrontent
    if (vJoueur.size() > 16) vJoueur.resize(16);
    cout << endl << "Les equipes vont s'affronter dans un tournoi sans loser bracket."  ;
    vector<vector<joueur>> loserBracket;

    while (vJoueur.size() > 1){ //La boucle s'arrete quand il ne reste qu'un joueur dans VJoueur
        //cout << endl << endl << "Debut du round "  << endl;
        //cout << "Il y a " << vJoueur.size() << " participants" << endl;
        //Création d'un vector de vector de joueur qui va stocker les gagnants pour le prochain tour.
        vector<vector<joueur>> prochainRoundVJouer;

        //Cette boucle permet de confronter les equipes 2 a 2.
        for (size_t i (0); i < vJoueur.size(); i += 2) {
            //cout << endl <<"Les equipes " <<  vJoueur[i][0].numEquipe << " et " << vJoueur[i+1][0].numEquipe << " s'affrontent." << endl;

            // Le gagnant de chaque jeu est stocké dans la variable gagnant.
            unsigned gagnant = pileOuFace(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            // On recupere l'indice du gagnant,
            // Si gagant vaut vJoueur[i][0].numEquipe alors equipeGagnanteIndex sera egal a i.
            // Sinon equipeGagnanteIndex vaut i+1
            size_t equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            // Les points du gagant augmentent de 1
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = shifumi(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = justePrix(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = jeuDuCailloux(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;


            gagnant = morpion(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            //On rajoute a la fin du vector prochainRoundVJouer le gagnant afin qu'il puisse jouer le prochain round.
            equipeGagnanteIndex = (vJoueur[i][0].points > vJoueur[i+1][0].points) ? i : i + 1;
            prochainRoundVJouer.push_back(vJoueur[equipeGagnanteIndex]);

            size_t equipePerdanteIndex = (vJoueur[i][0].points > vJoueur[i+1][0].points) ? i + 1 : i ;
            loserBracket.push_back(vJoueur[equipePerdanteIndex]);


            // On remet les scores a 0.
            vJoueur[i][0].points = 0;
            vJoueur[i+1][0].points = 0;
        }
        vJoueur = prochainRoundVJouer;
    }

    //loserbracket

    vector<vector<joueur>> final;
    final.push_back(vJoueur[0]);
    final.push_back(loserBracket[0]);


    size_t equipeGagnanteIndex = equipeGagnante(final, 0, 1);
    final[equipeGagnanteIndex][0].points++;
    cout << "c'est l'equipe " << final[0][0].numEquipe << " qui a gagne avec " << final[0][0].points << " points." << endl;
    return size_t(final[0][0].numEquipe);
}



// ------------ tournoiLigue1 -----------
size_t tournoiLigue1(vector<vector<joueur>> & vJoueur) {
    //Affronte 16 équipes dans un format de tournoi ligue1
    //Redimensionne le tableau de joueurs pour avoir seulement 16 équipes qui s'affrontent
    cout << endl << "Les equipes vont s'affronter dans un tournoi ligue 1."  ;
    if (vJoueur.size() > 16) vJoueur.resize(16);

    // Grace a la double boucle, chaque equipe va affronter toutes les autres equipes
    for (size_t i = 0; i < vJoueur.size(); i=i+1) {
        /*
         * L'indice j commence a i+1 pour eviter que :
         * - Deux equipes s'affrontent plusieurs fois entre elles.
         * - Une equipe s'affronte elle même.
        */
        for (size_t j = i+1; j < vJoueur.size(); j=j+1) {
            unsigned gagnant = pileOuFace(vJoueur[i][0].numEquipe,vJoueur[j][0].numEquipe);
            size_t equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : j;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = shifumi(vJoueur[i][0].numEquipe,vJoueur[j][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : j;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = justePrix(vJoueur[i][0].numEquipe,vJoueur[j][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : j;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = jeuDuCailloux(vJoueur[i][0].numEquipe,vJoueur[j][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : j;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = morpion(vJoueur[i][0].numEquipe,vJoueur[j][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : j;
            vJoueur[equipeGagnanteIndex][0].points++;
        }
    }

    size_t equipeGagnanteIndex = 0;
    unsigned maxPoints = 0;
    for (size_t i = 0; i < vJoueur.size(); ++i) {
        if (vJoueur[i][0].points > maxPoints) {
            maxPoints = vJoueur[i][0].points;
            equipeGagnanteIndex = i;
        }
    }
    /*
    for (size_t i = 0; i < vJoueur.size(); i=i+1) {
        //cout << "C'est l'equipe " << vJoueur[i][0].numEquipe << " qui a gagne avec " << vJoueur[i][0].points << " points." << endl;
    }*/
    cout << endl << "C'est l'equipe " << vJoueur[equipeGagnanteIndex][0].numEquipe << " qui a gagne avec " << vJoueur[equipeGagnanteIndex][0].points << " points." << endl;

    return size_t(vJoueur[equipeGagnanteIndex][0].numEquipe);
}

// ------------ tournoiSuisse -----------
size_t tournoiSuisse(vector<vector<joueur>> & vJoueur) {
    if (vJoueur.size() > 16) vJoueur.resize(16);

    size_t nombreRounds = 4; // def nombre de rounds

    for (size_t ronde = 1; ronde <= nombreRounds; ++ronde) {

        
        // Triez les équipes en fonction des points avant chaque ronde
        sort(vJoueur.begin(), vJoueur.end(), [](const auto &a, const auto &b) {
            return a[0].points > b[0].points;
        });
        // faire duel
        for (size_t i = 0; i < vJoueur.size(); i += 2) {

            //____match____
            unsigned gagnant = pileOuFace(vJoueur[i][0].numEquipe, vJoueur[i + 1][0].numEquipe);
            size_t equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = shifumi(vJoueur[i][0].numEquipe, vJoueur[i + 1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = justePrix(vJoueur[i][0].numEquipe, vJoueur[i + 1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = jeuDuCailloux(vJoueur[i][0].numEquipe, vJoueur[i + 1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

            gagnant = morpion(vJoueur[i][0].numEquipe, vJoueur[i + 1][0].numEquipe);
            equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
            vJoueur[equipeGagnanteIndex][0].points++;

        }
    }

    // Trouvez et imprimez l'équipe gagnante du tournoi suisse
    size_t equipeGagnanteIndex = 0;
    unsigned maxPoints = 0;
    for (size_t i = 0; i < vJoueur.size(); ++i) {
        if (vJoueur[i][0].points > maxPoints) {
            maxPoints = vJoueur[i][0].points;
            equipeGagnanteIndex = i;
        }
    }

    cout << endl << "C'est l'équipe " << vJoueur[equipeGagnanteIndex][0].numEquipe
         << " qui a gagné le tournoi suisse avec " << vJoueur[equipeGagnanteIndex][0].points << " points." << endl;

        return size_t(vJoueur[equipeGagnanteIndex][0].numEquipe);
}




int main(){
    string chemin = "C:\\Users\\colin\\Desktop\\sae101\\extrairedonnee\\liste_etud_avec_com.txt";
    vector<vector<joueur>> equipes = saisirEquipe(chemin);
    vector<int> Tournoi_Graine = recuperationGraineEtTournoi(chemin);

    //Initialiser l'aléatoire
    srand(Tournoi_Graine[1]);

    //Lancement du bon tournoi
    if (Tournoi_Graine[0] == 1)
        tournoiLigue1(equipes);
    else if (Tournoi_Graine[0] == 2)
        tournoiSuisse(equipes);
    else if (Tournoi_Graine[0] == 3)
        tournoiSansLoserBracket(equipes);
    else
        tournoiLigue1(equipes);
    return 0;
}
