#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <tuple>


using namespace std;


// -----------------------------------------------------------------------------
// ----------------------- Récupération des donneés -----------------------
// -----------------------------------------------------------------------------

struct joueur {
    string nom;
    string prenom;
    unsigned numEquipe;
    unsigned points ;
};

vector<vector<joueur>> saisirEquipe (const string & chemin){
    // Recupere les joueurs de chaques equipes a partir d'un fichier passe en parametre
    ifstream ifs (chemin);
    string nom;
    string prenom;
    string numEquipeStr;
    unsigned point = 0;
    vector<vector<joueur>> equipes (19);
    cout << "Recuperation des equipes." << endl;
    for(int i = 0; i < 114; ++i){
        getline (ifs, nom);
        //cout << nom << endl;
        getline (ifs, prenom);
        //cout << prenom << endl;
        getline(ifs, numEquipeStr);
        //cout << numEquipeStr << endl;
        unsigned numEquipe = stoi(numEquipeStr);
        equipes[numEquipe-1].push_back(joueur {nom, prenom, numEquipe, point});
    }
    return equipes;
}

int recuperationGraine (const string & chemin){
    // Recupere la graine a partir d'un fichier passe en parametre
    ifstream ifs (chemin);
    string vent;
    string graine ;
    for(int i = 0; i < 114; ++i){
        getline (ifs, vent);
        getline (ifs, vent);
        getline(ifs, vent);
    }
    getline(ifs, graine);
    cout << "la graine est : " << graine <<endl ;
    int graine2 = stoi(graine);
    cout << "---------------------" << endl;
    return graine2;
}


// -----------------------------------------------------------------------------
// ----------------------- Jeux -----------------------
// -----------------------------------------------------------------------------


// ------------ pileOuFace -----------
unsigned pileOuFace(const unsigned & j1, const unsigned j2) {
    //Affronte deux equipes au pile ou face
    //0 pour pile et 1 pour face
    int resultat = rand() % 2;
    if (resultat == 0) {
        cout << "Le gagant de la manche est l'equipe " << j1 << endl;
        return j1;
    }
    cout << "Le gagant de la manche est l'equipe " << j2 << endl;
    return j2;
}


// ------------ shifumi -----------
unsigned shifumi(const unsigned & j1, const unsigned j2) {
    //Affronte deux equipes au shifumi
    //0 pour Pierre, 1 pour Papier, 2 pour Ciseaux
    string coupj1 = to_string(rand() % 2);
    string coupj2 = "2";
    while (true){
        if ((coupj1 == "0" && coupj2 == "2") || (coupj1 == "1" && coupj2 == "0") || (coupj1 == "2" && coupj2 == "1")) {
            cout << "Le gagant de la manche est l'equipe " << j1 << endl;
            return j1;
        }
        else {
            cout << "Le gagant de la manche est l'equipe " << j2 << endl;
            return j2;
        }
    }
}

// ------------ justePrix -----------
unsigned justePrix(const unsigned & j1, const unsigned & j2){
    int nbSecret = rand() % 10;
    cout << "Le nombre secret est " << nbSecret << endl;
    bool j1Turn = true;
    int limiteMin = 0;
    int limiteMax = 10;
    int coupJ;
    while(true){
        coupJ = (rand() % (limiteMax - limiteMin)) + limiteMin;
        cout << coupJ << limiteMin << limiteMax;
        if(j1Turn){
            cout << "L'equipe 1 pense au nombre "<< coupJ << endl;
            if(coupJ == nbSecret){
                cout << "Le gagant de la manche est l'equipe " << j1 << endl;
                return j1;
            }else if(coupJ > nbSecret){
                //cout << coupJ << " trop grand j1" << endl;
                limiteMax = coupJ ;
            }else{
                limiteMin = coupJ ;
                //cout << coupJ << " trop petit j1" << endl;
            }
            j1Turn = false;
        }else{
            cout << "L'equipe 2 pense au nombre " << coupJ << endl;
            if(coupJ == nbSecret){
                cout << "Le gagant de la manche est l'equipe " << j2 << endl;
                return j2;
            }else if(coupJ > nbSecret){
                // << coupJ << " trop grand j2" << endl;
                limiteMax = coupJ;
            }else{

                limiteMin = coupJ;
                //cout << coupJ << " trop petit j2" << endl;
            }
            j1Turn = true;
        }
    }
}


unsigned jeuDuCailloux (const unsigned & j1, const unsigned & j2){
    //Affronte deux equipes au jeu du cailloux
    int result1 = 3;
    int result2 = 3;
    bool j1Turn = true;
    int coupJ1;
    int coupJ2;
    int winner;
    while (true){
        coupJ1 = (rand() % 3)+1;
        coupJ2 = (rand() % 3)+1;
        if (j1Turn){
            cout << "L'equipe " << j1 << " cache " << coupJ1 <<" cailloux et " << "l'equipe " << j2 << " pense qu'elle en cache " << coupJ2 << endl ;
        }
        else{
            cout << "L'equipe "<< j2 << " cache " << coupJ2 <<" cailloux et " <<  "l'equipe " <<j1 << " pense qu'elle en cache " << coupJ1 << endl ;
        }
        if ((coupJ1 == coupJ2 && j1Turn) ) { // 2 doit deviner, a raison, donc prend le nombre que 1 a caché
            result2 += coupJ1;
            result1 -= coupJ1;
            cout << "L'equipe "<< j2 << " gagne la manche." << endl ;
            cout << "L'equipe "<< j1 << " possede " << result1 << " et " <<  "l'equipe "<< j2 << " possede " << result2 << endl ;
            j1Turn = false;
        }
        else if(coupJ1 != coupJ2 && j1Turn == 0) {// 1 doit deviner, a tord, donc 2 prend le nombre que 2 a caché
            result2 += coupJ2;
            result1 -= coupJ2;
            cout << "L'equipe "<< j2 << " gagne la manche." << endl ;
            cout << "L'equipe "<< j1 << " possede " << result1 << " et " <<  "l'equipe "<< j2 << " possede " << result2 << endl ;
            j1Turn = true;
        }
        else if ((coupJ1 == coupJ2 && j1Turn==0) ) {// 1 doit deviner, a raison, donc prend le nombre que 2 a caché
            result2 -= coupJ2;
            result1 += coupJ2;
            cout << "L'equipe "<< j1 << " gagne la manche." << endl ;
            cout << "L'equipe "<< j1 << " possede " << result1 << " et " <<  "l'equipe "<< j2 << " possede " << result2 << endl ;
            j1Turn = true;
        }
        else {// 2 doit deviner, a tord,  1 donc prend le nombre que 1 a caché
            result2 -= coupJ1 ;
            result1 += coupJ1 ;
            cout << "L'equipe "<< j1 << " gagne la manche." << endl ;
            cout << "L'equipe "<< j1 << " possede " << result1 << " et " <<  "l'equipe "<< j2 << " possede " << result2 << endl ;
            j1Turn = false;
        }
        if (result1 < 1){
            winner = j2;
            cout << "Le gagant de la manche est l'equipe " << j2 << endl;
            break;
        }else if(result2 < 1){
            cout << "Le gagant de la manche est l'equipe " << j1 << endl;
            winner = j1;
            break;
        }

    }
    return winner;
}



// -----------------------------------------------------------------------------
// ----------------------- Tournoi -----------------------
// -----------------------------------------------------------------------------


void affichTabJoueur (const vector<vector<joueur>> & vJ){
    //    for (const auto & equipe  : vector<vector<joueur>>){
    for (size_t i (0); i < vJ.size(); ++i) {
        cout << "numero equipe : " << i+1 << endl;
        for (const auto & _joueur  : vJ[i])
            cout << _joueur.nom << " " << _joueur.prenom << endl;
    }
}


size_t equipeGagnante(const vector<vector<joueur>> & vJoueur, const size_t & posEquipe1, const size_t & posEquipe2) {
    return posEquipe2; //(vJoueur[posEquipe1][0].points > vJoueur[posEquipe2][0].points) ? posEquipe1 : posEquipe2;
}



// ------------ tournoiSansLoserBracket -----------
size_t tournoiSansLoserBracket (vector<vector<joueur>> & vJoueur){
    //Affronte 16 équipes dans un format de tournoi sans loser bracket
    if (vJoueur.size() > 16) vJoueur.resize(16);
    cout << endl << "Les equipes vont s'affronter dans un tournoi sans loser bracket." << endl << endl ;

    //Premier tour avec 16 équipes qui s'affrontent sur le pile ou face.
    cout << "Debut du round "  << endl;
    cout << "Il y a " << vJoueur.size() << " participants" << endl;
    //Création d'un vector de vector de joueur qui va stocker les gagnants pour le prochain tour.
    vector<vector<joueur>> prochainRoundVJouer;
    //Cette boucle permet de confronter les equipes 2 a 2.
    for (size_t i (0); i < vJoueur.size(); i += 2) {
        cout << "Les equipes " <<  vJoueur[i][0].numEquipe << " et " << vJoueur[i+1][0].numEquipe << " s'affrontent sur le pile ou face." << endl;
        //Le gagnant du jeu pile ou face est stocké dans la variable gagnant.
        unsigned gagnant = pileOuFace(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);/*Change en fonction du jeu sur lequel les equipes s'affrontent*/
        //equipeGagnanteIndex est l'indice du l'equipe gagnante, si gagnant == vJoueur[i][0].numEquipe
        //alors equipeGagnanteIndex sera égal a i, sinon il sera egal a i+1
        size_t equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
        //On rajoute a la fin du vector prochainRoundVJouer le joueur gagant afin qu'il puisse jouer le prochain round.
        prochainRoundVJouer.push_back(vJoueur[equipeGagnanteIndex]);
    }
    vJoueur = prochainRoundVJouer;

    //Quart de final avec 8 équipes qui s'affrontent sur le shifumi.
    cout << endl << "Debut du round "  << endl;
    cout << "Il y a " << vJoueur.size() << " participants" << endl;
    prochainRoundVJouer = {};
    for (size_t i (0); i < vJoueur.size(); i += 2) {
        cout << "Les equipes " <<  vJoueur[i][0].numEquipe << " et " << vJoueur[i+1][0].numEquipe << " s'affrontent sur shifumi." << endl;
        unsigned gagnant = shifumi(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
        size_t equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
        prochainRoundVJouer.push_back(vJoueur[equipeGagnanteIndex]);
    }
    vJoueur = prochainRoundVJouer;

    //Demi final avec 4 équipes qui s'affrontent sur le juste prix.
    cout << endl << "Debut du round "  << endl;
    cout << "Il y a " << vJoueur.size() << " participants" << endl;
    prochainRoundVJouer = {};
    for (size_t i (0); i < vJoueur.size(); i += 2) {
        cout << "Les equipes " <<  vJoueur[i][0].numEquipe << " et " << vJoueur[i+1][0].numEquipe << " s'affrontent sur justePrix." << endl;
        unsigned gagnant = justePrix(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
        size_t equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
        prochainRoundVJouer.push_back(vJoueur[equipeGagnanteIndex]);
    }
    vJoueur = prochainRoundVJouer;

    //Final avec 2 équipes qui s'affrontent sur le jeu du cailloux.
    cout << endl << "Debut du round "  << endl;
    cout << "Il y a " << vJoueur.size() << " participants" << endl;
    prochainRoundVJouer = {};
    for (size_t i (0); i < vJoueur.size(); i += 2) {
        cout << "Les equipes " <<  vJoueur[i][0].numEquipe << " et " << vJoueur[i+1][0].numEquipe << " s'affrontent sur le jeu du cailloux." << endl;
        unsigned gagnant = jeuDuCailloux(vJoueur[i][0].numEquipe, vJoueur[i+1][0].numEquipe);
        size_t equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : i + 1;
        prochainRoundVJouer.push_back(vJoueur[equipeGagnanteIndex]);
    }
    vJoueur = prochainRoundVJouer;
    cout << endl << "c'est l'equipe " << vJoueur[0][0].numEquipe << " qui a gagne." << endl;
    return size_t(vJoueur[0][0].numEquipe);
}


// ------------ tournoiAvecLoserBracket -----------
size_t tournoiAvecLoserBracket(vector<vector<joueur>> & vJoueur) {
    if (vJoueur.size() > 16) vJoueur.resize(16);
    vector<vector<joueur>> loserBracket;
    while (vJoueur.size() > 1 || loserBracket.size() > 1) {
        vector<vector<joueur>> prochainRoundVJouer;
        for (size_t i(0); i < vJoueur.size(); i += 2) {
            size_t equipeGagnanteIndex = equipeGagnante(vJoueur, i, i + 1);
            vJoueur[equipeGagnanteIndex][0].points++;
            prochainRoundVJouer.push_back(vJoueur[equipeGagnanteIndex]);
        }
        vJoueur = prochainRoundVJouer;
        for (size_t i(0); i < loserBracket.size(); i += 2) {
            size_t equipeGagnanteIndex = equipeGagnante(loserBracket, i, i + 1);
            loserBracket[equipeGagnanteIndex][0].points++;
            prochainRoundVJouer.push_back(loserBracket[equipeGagnanteIndex]);
        }
        loserBracket = prochainRoundVJouer;
    }
    vector<vector<joueur>> final;
    final.push_back(vJoueur[0]);
    final.push_back(loserBracket[0]);
    size_t equipeGagnanteIndex = equipeGagnante(final, 0, 1);
    final[equipeGagnanteIndex][0].points++;
    cout << "c'est l'equipe " << final[0][0].numEquipe << " qui a gagne avec " << final[0][0].points << " points." << endl;
    return size_t(final[0][0].numEquipe);
}



// ------------ tournoiLigue1 -----------
size_t tournoiLigue1(vector<vector<joueur>> & vJoueur) {
    if (vJoueur.size() > 16) vJoueur.resize(16);
    //Manche pile ou face
    for (size_t i = 0; i < vJoueur.size(); i=i+1) {
        for (size_t j = i+1; j < vJoueur.size(); j=j+1) {
            cout << "Les equipes " <<  vJoueur[i][0].numEquipe << " et " << vJoueur[i+1][0].numEquipe << " s'affrontent sur le pile ou face." << endl;
            unsigned gagnant = pileOuFace(vJoueur[i][0].numEquipe,vJoueur[j][0].numEquipe);
            size_t equipeGagnanteIndex = (gagnant == vJoueur[i][0].numEquipe) ? i : j;
            vJoueur[equipeGagnanteIndex][0].points++;
        }
    }
    /*
    //Manche shifumi
    for (size_t i = 5; i < 10; i=i+1) {
        for (size_t j = i+1; j < vJoueur.size(); j=j+1) {
            string gagnant = pileOuFace();
            size_t equipeGagnanteIndex = (gagnant == "1") ? i : j;
            vJoueur[equipeGagnanteIndex][0].points++;
        }
    }*/
    /*
    for (size_t i = 0; i < vJoueur.size(); i=i+1) {
        for (size_t j = 0; j < vJoueur.size(); j=j+1) {
            string gagnant = pileOuFace();
            size_t equipeGagnanteIndex = (gagnant == "1") ? j : j+1;
            vJoueur[equipeGagnanteIndex][0].points++;
        }
    }
*/
    size_t equipeGagnanteIndex = 0;
    unsigned maxPoints = 0;
    for (size_t i = 0; i < vJoueur.size(); ++i) {
        if (vJoueur[i][0].points > maxPoints) {
            maxPoints = vJoueur[i][0].points;
            equipeGagnanteIndex = i;
        }
    }

    for (size_t i = 0; i < vJoueur.size(); i=i+1) {
        cout << "C'est l'equipe " << vJoueur[i][0].numEquipe << " qui a gagne avec " << vJoueur[i][0].points << " points." << endl;}
    cout << endl << "C'est l'equipe " << vJoueur[equipeGagnanteIndex][0].numEquipe << " qui a gagne avec " << vJoueur[equipeGagnanteIndex][0].points << " points." << endl;

    return size_t(vJoueur[equipeGagnanteIndex][0].numEquipe);
}

// ------------ tournoiSuisse -----------
/*
void jouerTour(vector<Joueur>& joueurs) {
    // Apparier les joueurs avec des scores similaires
    for (size_t i = 0; i < joueurs.size(); i += 2) {
        cout << joueurs[i].nom << " contre " << joueurs[i + 1].nom << endl;

        // Simuler un match et mettre à jour les scores
        // Pour simplifier, supposons un résultat aléatoire (victoire ou défaite)
        int resultat; // 0 pour défaite, 1 pour victoire
        joueurs[i].score += resultat;
        joueurs[i + 1].score += (1 - resultat);
    }
}

// Fonction pour exécuter le tournoi suisse
void executerTournoiSuisse(vector<Joueur>& joueurs, size_t numRounds) {
    for (size_t tour = 1; tour <= numRounds; ++tour) {
        cout << "Tour " << tour << ":" << endl;
        jouerTour(joueurs);

        // Trier les joueurs en fonction des scores
        sort(joueurs.begin(), joueurs.end(), [](const Joueur& a, const Joueur& b) {
            return a.score > b.score;
        });

        // Afficher le classement actuel
        cout << "\nClassement actuel :" << endl;
        for (const auto& joueur : joueurs) {
            cout << joueur.nom << " - " << joueur.score << " points" << endl;
        }

        cout << "\n------------------------\n";
    }
}
*/




int main(){
    string chemin = "C:\\Users\\colin\\Desktop\\sae101\\extrairedonnee\\liste_etud_avec_com.txt";
    vector<vector<joueur>> equipes = saisirEquipe(chemin);
    int graine = recuperationGraine(chemin);
    srand(graine);
    tournoiSansLoserBracket(equipes);
    //jeuDuCailloux(1,2);
    //justePrix(1,2);
    //tournoiLigue1 (equipes);
    //affichTabJoueur(equipes);
    return 0;
}
